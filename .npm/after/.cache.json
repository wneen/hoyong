{"_id":"after","_rev":"51-8e866bcbf83123f6bf45bdafa8cbb3fe","name":"after","description":"after - tiny flow control","dist-tags":{"latest":"0.8.1"},"versions":{"0.1.0":{"name":"after","description":"after - tiny flow control","version":"0.1.0","author":{"name":"Raynos","email":"raynos2@gmail.com"},"contributors":[{"name":"Raynos","email":"raynos2@gmail.com","url":"http://raynos.org"}],"devDependencies":{"vows":"0.5.9"},"keywords":["flowcontrol","after","flow"],"repository":{"type":"git","url":"git://github.com/Raynos/after.js.git"},"main":"after","scripts":{},"engines":{"node":"0.4.x"},"_npmJsonOpts":{"file":"/home/raynos/.npm/after/0.1.0/package/package.json","wscript":false,"contributors":false,"serverjs":false},"_id":"after@0.1.0","dependencies":{},"_engineSupported":true,"_npmVersion":"1.0.23","_nodeVersion":"v0.4.10","_defaultsLoaded":true,"dist":{"shasum":"0bf9a392e78dbf23e7f3fafa9177ddc714dc54fe","tarball":"http://registry.npmjs.org/after/-/after-0.1.0.tgz"},"maintainers":[{"name":"raynos","email":"raynos2@gmail.com"}],"_npmUser":{"name":"raynos","email":"raynos2@gmail.com"},"directories":{}},"0.1.3":{"name":"after","description":"after - tiny flow control","version":"0.1.3","author":{"name":"Raynos","email":"raynos2@gmail.com"},"contributors":[{"name":"Raynos","email":"raynos2@gmail.com","url":"http://raynos.org"}],"devDependencies":{"vows-fluent":"0.1.1"},"keywords":["flowcontrol","after","flow"],"repository":{"type":"git","url":"git://github.com/Raynos/after.js.git"},"main":"after","scripts":{},"engines":{"node":"0.4.x"},"_npmJsonOpts":{"file":"/home/raynos/.npm/after/0.1.3/package/package.json","wscript":false,"contributors":false,"serverjs":false},"_id":"after@0.1.3","dependencies":{},"_engineSupported":true,"_npmVersion":"1.0.23","_nodeVersion":"v0.4.10","_defaultsLoaded":true,"dist":{"shasum":"ab3d83f0513dbaac19b82434aa7bfda5813a9196","tarball":"http://registry.npmjs.org/after/-/after-0.1.3.tgz"},"maintainers":[{"name":"raynos","email":"raynos2@gmail.com"}],"_npmUser":{"name":"raynos","email":"raynos2@gmail.com"},"directories":{}},"0.1.4":{"name":"after","description":"after - tiny flow control","version":"0.1.4","author":{"name":"Raynos","email":"raynos2@gmail.com"},"contributors":[{"name":"Raynos","email":"raynos2@gmail.com","url":"http://raynos.org"}],"devDependencies":{"vows-fluent":"0.1.9"},"keywords":["flowcontrol","after","flow"],"repository":{"type":"git","url":"git://github.com/Raynos/after.js.git"},"main":"after","scripts":{},"engines":{"node":"0.4.x"},"_npmJsonOpts":{"file":"/home/raynos/.npm/after/0.1.4/package/package.json","wscript":false,"contributors":false,"serverjs":false},"_id":"after@0.1.4","dependencies":{},"_engineSupported":true,"_npmVersion":"1.0.23","_nodeVersion":"v0.4.10","_defaultsLoaded":true,"dist":{"shasum":"b40f2b9d172eadda53769b00dcb6369bbb1dfc03","tarball":"http://registry.npmjs.org/after/-/after-0.1.4.tgz"},"maintainers":[{"name":"raynos","email":"raynos2@gmail.com"}],"_npmUser":{"name":"raynos","email":"raynos2@gmail.com"},"directories":{}},"0.1.5":{"name":"after","description":"after - tiny flow control","version":"0.1.5","author":{"name":"Raynos","email":"raynos2@gmail.com"},"contributors":[{"name":"Raynos","email":"raynos2@gmail.com","url":"http://raynos.org"}],"devDependencies":{"vows-fluent":"0.1.9"},"keywords":["flowcontrol","after","flow"],"repository":{"type":"git","url":"git://github.com/Raynos/after.js.git"},"main":"after","scripts":{},"engines":{"node":"0.4.x"},"_npmJsonOpts":{"file":"/home/raynos/.npm/after/0.1.5/package/package.json","wscript":false,"contributors":false,"serverjs":false},"_id":"after@0.1.5","dependencies":{},"_engineSupported":true,"_npmVersion":"1.0.23","_nodeVersion":"v0.4.10","_defaultsLoaded":true,"dist":{"shasum":"bea01692f875c192a16cc26c17826a783912c469","tarball":"http://registry.npmjs.org/after/-/after-0.1.5.tgz"},"maintainers":[{"name":"raynos","email":"raynos2@gmail.com"}],"_npmUser":{"name":"raynos","email":"raynos2@gmail.com"},"directories":{}},"0.1.6":{"name":"after","description":"after - tiny flow control","version":"0.1.6","author":{"name":"Raynos","email":"raynos2@gmail.com"},"contributors":[{"name":"Raynos","email":"raynos2@gmail.com","url":"http://raynos.org"}],"devDependencies":{"tester":"0.0.1"},"keywords":["flowcontrol","after","flow","control","arch"],"repository":{"type":"git","url":"git://github.com/Raynos/after.js.git"},"main":"src/after","engines":{"node":"0.5.x"},"_npmJsonOpts":{"file":"/home/raynos/.npm/after/0.1.6/package/package.json","wscript":false,"contributors":false,"serverjs":false},"_id":"after@0.1.6","dependencies":{},"_engineSupported":true,"_npmVersion":"1.0.30","_nodeVersion":"v0.5.5","_defaultsLoaded":true,"dist":{"shasum":"9d344114fcb1f1616d583a42ba54e8ecaedcb873","tarball":"http://registry.npmjs.org/after/-/after-0.1.6.tgz"},"maintainers":[{"name":"raynos","email":"raynos2@gmail.com"}],"_npmUser":{"name":"raynos","email":"raynos2@gmail.com"},"directories":{}},"0.1.7":{"name":"after","description":"after - tiny flow control","version":"0.1.7","author":{"name":"Raynos","email":"raynos2@gmail.com"},"contributors":[{"name":"Raynos","email":"raynos2@gmail.com","url":"http://raynos.org"}],"devDependencies":{"tester":"0.0.3"},"keywords":["flowcontrol","after","flow","control","arch"],"repository":{"type":"git","url":"git://github.com/Raynos/after.js.git"},"main":"src/after","engines":{"node":"0.6.x"},"_npmUser":{"name":"raynos","email":"raynos2@gmail.com"},"_id":"after@0.1.7","dependencies":{},"_engineSupported":true,"_npmVersion":"1.0.105","_nodeVersion":"v0.6.0","_defaultsLoaded":true,"dist":{"shasum":"e392d8756630c005e36d0554ed4bea463da7c210","tarball":"http://registry.npmjs.org/after/-/after-0.1.7.tgz"},"maintainers":[{"name":"raynos","email":"raynos2@gmail.com"}],"directories":{}},"0.1.8":{"name":"after","description":"after - tiny flow control","version":"0.1.8","author":{"name":"Raynos","email":"raynos2@gmail.com"},"contributors":[{"name":"Raynos","email":"raynos2@gmail.com","url":"http://raynos.org"}],"devDependencies":{"tester":"0.0.4"},"keywords":["flowcontrol","after","flow","control","arch"],"repository":{"type":"git","url":"git://github.com/Raynos/after.js.git"},"main":"src/after","engines":{"node":"0.6.x"},"_npmUser":{"name":"raynos","email":"raynos2@gmail.com"},"_id":"after@0.1.8","dependencies":{},"_engineSupported":true,"_npmVersion":"1.1.0-alpha-6","_nodeVersion":"v0.6.4","_defaultsLoaded":true,"dist":{"shasum":"27b9750e2103047b99128f306dceb16b7f0a1d81","tarball":"http://registry.npmjs.org/after/-/after-0.1.8.tgz"},"maintainers":[{"name":"raynos","email":"raynos2@gmail.com"}],"directories":{}},"0.2.0":{"name":"after","description":"after - tiny flow control","version":"0.2.0","author":{"name":"Raynos","email":"raynos2@gmail.com"},"contributors":[{"name":"Raynos","email":"raynos2@gmail.com","url":"http://raynos.org"}],"scripts":{"test":"node test/main-test.js"},"devDependencies":{"tester":"0.0.4"},"keywords":["flowcontrol","after","flow","control","arch"],"repository":{"type":"git","url":"git://github.com/Raynos/after.js.git"},"main":"src/after","engines":{"node":"0.6 || 0.4"},"_npmUser":{"name":"raynos","email":"raynos2@gmail.com"},"_id":"after@0.2.0","dependencies":{},"_engineSupported":true,"_npmVersion":"1.1.0-alpha-6","_nodeVersion":"v0.6.4","_defaultsLoaded":true,"dist":{"shasum":"bfdba338dbb670d6ca3f73cad6d7ff2db4acb71a","tarball":"http://registry.npmjs.org/after/-/after-0.2.0.tgz"},"maintainers":[{"name":"raynos","email":"raynos2@gmail.com"}],"directories":{}},"0.3.1":{"name":"after","description":"after - tiny flow control","version":"0.3.1","author":{"name":"Raynos","email":"raynos2@gmail.com"},"contributors":[{"name":"Raynos","email":"raynos2@gmail.com","url":"http://raynos.org"}],"scripts":{"test":"make test"},"devDependencies":{"mocha":"0.10.2"},"keywords":["flowcontrol","after","flow","control","arch"],"repository":{"type":"git","url":"git://github.com/Raynos/after.js.git"},"main":"lib/after","engines":{"node":"0.6"},"_npmUser":{"name":"raynos","email":"raynos2@gmail.com"},"_id":"after@0.3.1","dependencies":{},"optionalDependencies":{},"_engineSupported":true,"_npmVersion":"1.1.0","_nodeVersion":"v0.6.6","_defaultsLoaded":true,"dist":{"shasum":"e8a1065f37c01d394d6922fc4f9c1e61a66ad46b","tarball":"http://registry.npmjs.org/after/-/after-0.3.1.tgz"},"readme":"# After [![Build Status][1]][2]\n\nAll the flow control you'll ever need\n\n## Status: production ready\n\n## Example\n\n    var after = require(\"after\"),\n        next = after(3, logItWorks);\n\n    next();\n    next();\n    next(); // it works\n\n    function logItWorks() {\n        console.log(\"it works!\");\n    }\n\n## Motivation \n\nMinimal flow control. A lot of the libraries out there are over kill. I want a small tool that gives me fundamental concrete building blocks\n\n## Documentation\n\n### after(count, callback) <a name=\"after\" href=\"#after\"><small><sup>link</sup></small></a>\n\n`after` takes a count and a callback and returns a function `next`. The callback get's invoked when the `next` function is invoked count number of times. The callback aggregates the data given to `next` as un-ordered parameters.\n\n    var next = after(3, printData);\n\n    next(\"foo\", \"bar\", { ... })\n    next({ ... });\n    next(42);\n\n    function printData() {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            console.log(arguments[i]);  \n        }\n        // in some order\n        // 42\n        // { ... }\n        // [ \"foo\", \"bar\", { ... }]\n    }\n\nNote that the internal counter is exposed as `next.count` so you can manually increment or decrement it in a dynamic fashion. This is useful for recursively algorithms that want to increment the counter.\n\n### after.unpack(arguments) <a name=\"unpack\" href=\"#unpack\"><small><sup>link</sup></small></a>\n\nUnpack data from after using a convention\n\n``` javascript\nvar next = after(2, function () {\n    var data = after.unpack(arguments); \n    /* data = { foo: \"bar\", baz: \"boz\"}; */\n});\n\nnext(\"foo\", \"bar\");\nnext(\"baz\", \"boz\");\n```\n\n### after set utilities\n\nThe following methods are asynchronous parallel versions of the `Array.prototype` methods.\n\nThey all take parameters `(set, iterator, optionalContext, finishedCallback)`\n\n - set : the set to operate on\n - iterator : iterator function that is called for every value in the set.\n    iterator has multiple signatures. Either `(callback)` or `(value, callback)` or `(value, index, callback)` or `(value, index, obj, callback)`. The last argument is always the callback. The callback should be invoked when your done iterating over that item. You may invoke the callback with `(err, result)`\n - optionalContext : optional parameter, if given it will be the value of `this` \n    inside the iterator\n - finishedCallback : this callback is invoked when every iterator has invoked it's\n    individual callback. It has a signature of `(err, result)`. The `err` parameter\n    is whatever passed an error first or `null`. The result parameter is specific\n    to each set utility function\n\nNote that `reduce` has an `optionalInitialValue` instead of an `optionalContext`.\n\nAlso reduce's signature is `(memo, value, index, obj, callback)` or any of the shorter forms like `(memo, value, callback)`.\n\nApart from reduce and reduceRight all of these set iterators run their iterators in parallel over the set\n\n### after.forEach(set, iterator, optionalContext, finishedCallback) <a name=\"after.forEach\" href=\"#after.forEach\"><small><sup>link</sup></small></a>\n\nFor `.forEach` the `result` parameter of the finishedCallback is always undefined.\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.forEach(set, synchronizeOAuth, finished)\n\n    function synchronizeOAuth(userObject, oAuthName, callback) {\n        getOAuth(oAuthName).sychronize(userObject, callback);\n    }\n\n    function finished(err) {\n        if (err) throw err;\n    }\n\n### after.map(set, iterator, optionalContext, finishedCallback) <a name=\"after.map\" href=\"#after.map\"><small><sup>link</sup></small></a>\n\nFor `.map` the `result` parameter of the finishedCalllback is the object your mapping too.\n\nmap will return a result that either inherits from your objects prototype or is an array depending on whether the call value is an object or an array\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.map(set, getOAuthUser, finished);\n\n    function getOauthUser(userObject, oAuthName, callback) {\n        getOAuth(oAuthName).getUser(userObject, callback);\n    }\n\n    function finished (err, oAuthUserObjects) {\n        if (err) throw err;\n        for (var service in oAuthUserObjects) {\n            ...\n        }\n    }\n\n### after.reduce(set, iterator, optionalInitialValue, finishedCallback) <a name=\"after.reduce\" href=\"#after.reduce\"><small><sup>link</sup></small></a>\n\nFor `.reduce` the `result` parameter is the reduced value.\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.reduce(set, aggregateFriends, 0, finished);\n\n    function aggregateFriends(memo, userObject, oAuthName, callback) {\n        getOAuth(oAuthName)\n            .getNumberOfFriends(userObject, function (err, friends) {\n                callback(err, friends + memo);\n            });\n    }\n\n    function finished (err, numberOfFriends) {\n        if (err) throw err;\n        ...\n    }\n    \n### after.reduceRight(...) <a name=\"after.reduceRight\" href=\"#after.reduceRight\"><small><sup>link</sup></small></a>\n\n`.reduceRight` is the same as `reduce` excepts runs over the object in reverse.\n\n### after.filter(set, iterator, optionalContext, finishedCallback) <a name=\"after.filter\" href=\"#after.filter\"><small><sup>link</sup></small></a>\n\nFor `.filter` the `result` is the filtered object/array.\n\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.filter(set, isRegistered, finished);\n\n    function isRegistered(memo, userObject, oAuthName, callback) {\n        getOAuth(oAuthName).userExists(userObject, callback);\n    }\n\n    function finished (err, usersThatExist) {\n        if (err) throw err;\n        ...\n    }\n\n### after.every(set, iterator, optionalContext, finishedCallback) <a name=\"after.every\" href=\"#after.every\"><small><sup>link</sup></small></a>\n\nEvery passes `true` to the finished callback if every callback in the iteration passed `true`.\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.every(set, isRegistered, finished);\n\n    function isRegistered(memo, userObject, oAuthName, callback) {\n        getOAuth(oAuthName).userExists(userObject, callback);\n    }\n\n    function finished (err, registeredOnAllServices) {\n        if (err) throw err;\n        ...\n    }\n\n### After.some(set, iterator, optionalContext, finishedCallback) <a name=\"after.some\" href=\"#after.some\"><small><sup>link</sup></small></a>\n\nSome passes `false` to the finished callback if every callback in the iteration passed `false`.\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.every(set, isRegistered, finished);\n\n    function isRegistered(memo, userObject, oAuthName, callback) {\n        getOAuth(oAuthName).userExists(userObject, callback);\n    }\n\n    function finished (err, registeredOnAnyServices) {\n        if (err) throw err;\n        ...\n    }\n\n## Installation\n\n`npm install after`\n\n## Tests\n\n`make test`\n\n## Blog post\n\n[Flow control in node.js][3]\n\n## Examples :\n\n - [Determining the end of asynchronous operations][4]\n - [In javascript what are best practices for executing multiple asynchronous functions][5]\n - [JavaScript performance long running tasks][6]\n - [Synchronous database queries with node.js][7]\n\n## Contributors\n\n - Raynos\n\n## MIT Licenced\n\n  [1]: https://secure.travis-ci.org/Raynos/after.js.png\n  [2]: http://travis-ci.org/Raynos/after.js\n  [3]: http://raynos.org/blog/2/Flow-control-in-node.js\n  [4]: http://stackoverflow.com/questions/6852059/determining-the-end-of-asynchronous-operations-javascript/6852307#6852307\n  [5]: http://stackoverflow.com/questions/6869872/in-javascript-what-are-best-practices-for-executing-multiple-asynchronous-functi/6870031#6870031\n  [6]: http://stackoverflow.com/questions/6864397/javascript-performance-long-running-tasks/6889419#6889419\n  [7]: http://stackoverflow.com/questions/6597493/synchronous-database-queries-with-node-js/6620091#6620091","maintainers":[{"name":"raynos","email":"raynos2@gmail.com"}],"directories":{}},"0.3.2":{"name":"after","description":"after - tiny flow control","version":"0.3.2","author":{"name":"Raynos","email":"raynos2@gmail.com"},"contributors":[{"name":"Raynos","email":"raynos2@gmail.com","url":"http://raynos.org"}],"scripts":{"test":"make test"},"devDependencies":{"mocha":"0.10.2"},"keywords":["flowcontrol","after","flow","control","arch"],"repository":{"type":"git","url":"git://github.com/Raynos/after.js.git"},"main":"lib/after","engines":{"node":"0.6"},"_npmUser":{"name":"raynos","email":"raynos2@gmail.com"},"_id":"after@0.3.2","dependencies":{},"optionalDependencies":{},"_engineSupported":true,"_npmVersion":"1.1.0","_nodeVersion":"v0.6.6","_defaultsLoaded":true,"dist":{"shasum":"9a26de3cf3650d6cdd395a2997531de3bd687c60","tarball":"http://registry.npmjs.org/after/-/after-0.3.2.tgz"},"readme":"# After [![Build Status][1]][2]\n\nAll the flow control you'll ever need\n\n## Status: production ready\n\n## Example\n\n    var after = require(\"after\"),\n        next = after(3, logItWorks);\n\n    next();\n    next();\n    next(); // it works\n\n    function logItWorks() {\n        console.log(\"it works!\");\n    }\n\n## Motivation \n\nMinimal flow control. A lot of the libraries out there are over kill. I want a small tool that gives me fundamental concrete building blocks\n\n## Documentation\n\n### after(count, callback) <a name=\"after\" href=\"#after\"><small><sup>link</sup></small></a>\n\n`after` takes a count and a callback and returns a function `next`. The callback get's invoked when the `next` function is invoked count number of times. The callback aggregates the data given to `next` as un-ordered parameters.\n\n    var next = after(3, printData);\n\n    next(\"foo\", \"bar\", { ... })\n    next({ ... });\n    next(42);\n\n    function printData() {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            console.log(arguments[i]);  \n        }\n        // in some order\n        // 42\n        // { ... }\n        // [ \"foo\", \"bar\", { ... }]\n    }\n\nNote that the internal counter is exposed as `next.count` so you can manually increment or decrement it in a dynamic fashion. This is useful for recursively algorithms that want to increment the counter.\n\n### after.unpack(arguments) <a name=\"unpack\" href=\"#unpack\"><small><sup>link</sup></small></a>\n\nUnpack data from after using a convention\n\n``` javascript\nvar next = after(2, function () {\n    var data = after.unpack(arguments); \n    /* data = { foo: \"bar\", baz: \"boz\"}; */\n});\n\nnext(\"foo\", \"bar\");\nnext(\"baz\", \"boz\");\n```\n\n### after set utilities\n\nThe following methods are asynchronous parallel versions of the `Array.prototype` methods.\n\nThey all take parameters `(set, iterator, optionalContext, finishedCallback)`\n\n - set : the set to operate on\n - iterator : iterator function that is called for every value in the set.\n    iterator has multiple signatures. Either `(callback)` or `(value, callback)` or `(value, index, callback)` or `(value, index, obj, callback)`. The last argument is always the callback. The callback should be invoked when your done iterating over that item. You may invoke the callback with `(err, result)`\n - optionalContext : optional parameter, if given it will be the value of `this` \n    inside the iterator\n - finishedCallback : this callback is invoked when every iterator has invoked it's\n    individual callback. It has a signature of `(err, result)`. The `err` parameter\n    is whatever passed an error first or `null`. The result parameter is specific\n    to each set utility function\n\nNote that `reduce` has an `optionalInitialValue` instead of an `optionalContext`.\n\nAlso reduce's signature is `(memo, value, index, obj, callback)` or any of the shorter forms like `(memo, value, callback)`.\n\nApart from reduce and reduceRight all of these set iterators run their iterators in parallel over the set\n\n### after.forEach(set, iterator, optionalContext, finishedCallback) <a name=\"after.forEach\" href=\"#after.forEach\"><small><sup>link</sup></small></a>\n\nFor `.forEach` the `result` parameter of the finishedCallback is always undefined.\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.forEach(set, synchronizeOAuth, finished)\n\n    function synchronizeOAuth(userObject, oAuthName, callback) {\n        getOAuth(oAuthName).sychronize(userObject, callback);\n    }\n\n    function finished(err) {\n        if (err) throw err;\n    }\n\n### after.map(set, iterator, optionalContext, finishedCallback) <a name=\"after.map\" href=\"#after.map\"><small><sup>link</sup></small></a>\n\nFor `.map` the `result` parameter of the finishedCalllback is the object your mapping too.\n\nmap will return a result that either inherits from your objects prototype or is an array depending on whether the call value is an object or an array\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.map(set, getOAuthUser, finished);\n\n    function getOauthUser(userObject, oAuthName, callback) {\n        getOAuth(oAuthName).getUser(userObject, callback);\n    }\n\n    function finished (err, oAuthUserObjects) {\n        if (err) throw err;\n        for (var service in oAuthUserObjects) {\n            ...\n        }\n    }\n\n### after.reduce(set, iterator, optionalInitialValue, finishedCallback) <a name=\"after.reduce\" href=\"#after.reduce\"><small><sup>link</sup></small></a>\n\nFor `.reduce` the `result` parameter is the reduced value.\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.reduce(set, aggregateFriends, 0, finished);\n\n    function aggregateFriends(memo, userObject, oAuthName, callback) {\n        getOAuth(oAuthName)\n            .getNumberOfFriends(userObject, function (err, friends) {\n                callback(err, friends + memo);\n            });\n    }\n\n    function finished (err, numberOfFriends) {\n        if (err) throw err;\n        ...\n    }\n    \n### after.reduceRight(...) <a name=\"after.reduceRight\" href=\"#after.reduceRight\"><small><sup>link</sup></small></a>\n\n`.reduceRight` is the same as `reduce` excepts runs over the object in reverse.\n\n### after.filter(set, iterator, optionalContext, finishedCallback) <a name=\"after.filter\" href=\"#after.filter\"><small><sup>link</sup></small></a>\n\nFor `.filter` the `result` is the filtered object/array.\n\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.filter(set, isRegistered, finished);\n\n    function isRegistered(memo, userObject, oAuthName, callback) {\n        getOAuth(oAuthName).userExists(userObject, callback);\n    }\n\n    function finished (err, usersThatExist) {\n        if (err) throw err;\n        ...\n    }\n\n### after.every(set, iterator, optionalContext, finishedCallback) <a name=\"after.every\" href=\"#after.every\"><small><sup>link</sup></small></a>\n\nEvery passes `true` to the finished callback if every callback in the iteration passed `true`.\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.every(set, isRegistered, finished);\n\n    function isRegistered(memo, userObject, oAuthName, callback) {\n        getOAuth(oAuthName).userExists(userObject, callback);\n    }\n\n    function finished (err, registeredOnAllServices) {\n        if (err) throw err;\n        ...\n    }\n\n### After.some(set, iterator, optionalContext, finishedCallback) <a name=\"after.some\" href=\"#after.some\"><small><sup>link</sup></small></a>\n\nSome passes `false` to the finished callback if every callback in the iteration passed `false`.\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.every(set, isRegistered, finished);\n\n    function isRegistered(memo, userObject, oAuthName, callback) {\n        getOAuth(oAuthName).userExists(userObject, callback);\n    }\n\n    function finished (err, registeredOnAnyServices) {\n        if (err) throw err;\n        ...\n    }\n\n## Installation\n\n`npm install after`\n\n## Tests\n\n`make test`\n\n## Blog post\n\n[Flow control in node.js][3]\n\n## Examples :\n\n - [Determining the end of asynchronous operations][4]\n - [In javascript what are best practices for executing multiple asynchronous functions][5]\n - [JavaScript performance long running tasks][6]\n - [Synchronous database queries with node.js][7]\n\n## Contributors\n\n - Raynos\n\n## MIT Licenced\n\n  [1]: https://secure.travis-ci.org/Raynos/after.js.png\n  [2]: http://travis-ci.org/Raynos/after.js\n  [3]: http://raynos.org/blog/2/Flow-control-in-node.js\n  [4]: http://stackoverflow.com/questions/6852059/determining-the-end-of-asynchronous-operations-javascript/6852307#6852307\n  [5]: http://stackoverflow.com/questions/6869872/in-javascript-what-are-best-practices-for-executing-multiple-asynchronous-functi/6870031#6870031\n  [6]: http://stackoverflow.com/questions/6864397/javascript-performance-long-running-tasks/6889419#6889419\n  [7]: http://stackoverflow.com/questions/6597493/synchronous-database-queries-with-node-js/6620091#6620091","maintainers":[{"name":"raynos","email":"raynos2@gmail.com"}],"directories":{}},"0.3.3":{"name":"after","description":"after - tiny flow control","version":"0.3.3","author":{"name":"Raynos","email":"raynos2@gmail.com"},"contributors":[{"name":"Raynos","email":"raynos2@gmail.com","url":"http://raynos.org"}],"scripts":{"test":"make test"},"devDependencies":{"mocha":"0.10.2"},"keywords":["flowcontrol","after","flow","control","arch"],"repository":{"type":"git","url":"git://github.com/Raynos/after.js.git"},"main":"lib/after","engines":{"node":"0.6"},"_npmUser":{"name":"raynos","email":"raynos2@gmail.com"},"_id":"after@0.3.3","dependencies":{},"optionalDependencies":{},"_engineSupported":true,"_npmVersion":"1.1.0","_nodeVersion":"v0.6.6","_defaultsLoaded":true,"dist":{"shasum":"63e3c61be2049f8d752e87cbeff70f2c90eca474","tarball":"http://registry.npmjs.org/after/-/after-0.3.3.tgz"},"readme":"# After [![Build Status][1]][2]\n\nAll the flow control you'll ever need\n\n## Status: production ready\n\n## Example\n\n    var after = require(\"after\"),\n        next = after(3, logItWorks);\n\n    next();\n    next();\n    next(); // it works\n\n    function logItWorks() {\n        console.log(\"it works!\");\n    }\n\n## Motivation \n\nMinimal flow control. A lot of the libraries out there are over kill. I want a small tool that gives me fundamental concrete building blocks\n\n## Documentation\n\n### after(count, callback) <a name=\"after\" href=\"#after\"><small><sup>link</sup></small></a>\n\n`after` takes a count and a callback and returns a function `next`. The callback get's invoked when the `next` function is invoked count number of times. The callback aggregates the data given to `next` as un-ordered parameters.\n\n    var next = after(3, printData);\n\n    next(\"foo\", \"bar\", { ... })\n    next({ ... });\n    next(42);\n\n    function printData() {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            console.log(arguments[i]);  \n        }\n        // in some order\n        // 42\n        // { ... }\n        // [ \"foo\", \"bar\", { ... }]\n    }\n\nNote that the internal counter is exposed as `next.count` so you can manually increment or decrement it in a dynamic fashion. This is useful for recursively algorithms that want to increment the counter.\n\n### after.unpack(arguments) <a name=\"unpack\" href=\"#unpack\"><small><sup>link</sup></small></a>\n\nUnpack data from after using a convention\n\n``` javascript\nvar next = after(2, function () {\n    var data = after.unpack(arguments); \n    /* data = { foo: \"bar\", baz: \"boz\"}; */\n});\n\nnext(\"foo\", \"bar\");\nnext(\"baz\", \"boz\");\n```\n\n### after set utilities\n\nThe following methods are asynchronous parallel versions of the `Array.prototype` methods.\n\nThey all take parameters `(set, iterator, optionalContext, finishedCallback)`\n\n - set : the set to operate on\n - iterator : iterator function that is called for every value in the set.\n    iterator has multiple signatures. Either `(callback)` or `(value, callback)` or `(value, index, callback)` or `(value, index, obj, callback)`. The last argument is always the callback. The callback should be invoked when your done iterating over that item. You may invoke the callback with `(err, result)`\n - optionalContext : optional parameter, if given it will be the value of `this` \n    inside the iterator\n - finishedCallback : this callback is invoked when every iterator has invoked it's\n    individual callback. It has a signature of `(err, result)`. The `err` parameter\n    is whatever passed an error first or `null`. The result parameter is specific\n    to each set utility function\n\nNote that `reduce` has an `optionalInitialValue` instead of an `optionalContext`.\n\nAlso reduce's signature is `(memo, value, index, obj, callback)` or any of the shorter forms like `(memo, value, callback)`.\n\nApart from reduce and reduceRight all of these set iterators run their iterators in parallel over the set\n\n### after.forEach(set, iterator, optionalContext, finishedCallback) <a name=\"after.forEach\" href=\"#after.forEach\"><small><sup>link</sup></small></a>\n\nFor `.forEach` the `result` parameter of the finishedCallback is always undefined.\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.forEach(set, synchronizeOAuth, finished)\n\n    function synchronizeOAuth(userObject, oAuthName, callback) {\n        getOAuth(oAuthName).sychronize(userObject, callback);\n    }\n\n    function finished(err) {\n        if (err) throw err;\n    }\n\n### after.map(set, iterator, optionalContext, finishedCallback) <a name=\"after.map\" href=\"#after.map\"><small><sup>link</sup></small></a>\n\nFor `.map` the `result` parameter of the finishedCalllback is the object your mapping too.\n\nmap will return a result that either inherits from your objects prototype or is an array depending on whether the call value is an object or an array\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.map(set, getOAuthUser, finished);\n\n    function getOauthUser(userObject, oAuthName, callback) {\n        getOAuth(oAuthName).getUser(userObject, callback);\n    }\n\n    function finished (err, oAuthUserObjects) {\n        if (err) throw err;\n        for (var service in oAuthUserObjects) {\n            ...\n        }\n    }\n\n### after.reduce(set, iterator, optionalInitialValue, finishedCallback) <a name=\"after.reduce\" href=\"#after.reduce\"><small><sup>link</sup></small></a>\n\nFor `.reduce` the `result` parameter is the reduced value.\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.reduce(set, aggregateFriends, 0, finished);\n\n    function aggregateFriends(memo, userObject, oAuthName, callback) {\n        getOAuth(oAuthName)\n            .getNumberOfFriends(userObject, function (err, friends) {\n                callback(err, friends + memo);\n            });\n    }\n\n    function finished (err, numberOfFriends) {\n        if (err) throw err;\n        ...\n    }\n    \n### after.reduceRight(...) <a name=\"after.reduceRight\" href=\"#after.reduceRight\"><small><sup>link</sup></small></a>\n\n`.reduceRight` is the same as `reduce` excepts runs over the object in reverse.\n\n### after.filter(set, iterator, optionalContext, finishedCallback) <a name=\"after.filter\" href=\"#after.filter\"><small><sup>link</sup></small></a>\n\nFor `.filter` the `result` is the filtered object/array.\n\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.filter(set, isRegistered, finished);\n\n    function isRegistered(memo, userObject, oAuthName, callback) {\n        getOAuth(oAuthName).userExists(userObject, callback);\n    }\n\n    function finished (err, usersThatExist) {\n        if (err) throw err;\n        ...\n    }\n\n### after.every(set, iterator, optionalContext, finishedCallback) <a name=\"after.every\" href=\"#after.every\"><small><sup>link</sup></small></a>\n\nEvery passes `true` to the finished callback if every callback in the iteration passed `true`.\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.every(set, isRegistered, finished);\n\n    function isRegistered(memo, userObject, oAuthName, callback) {\n        getOAuth(oAuthName).userExists(userObject, callback);\n    }\n\n    function finished (err, registeredOnAllServices) {\n        if (err) throw err;\n        ...\n    }\n\n### After.some(set, iterator, optionalContext, finishedCallback) <a name=\"after.some\" href=\"#after.some\"><small><sup>link</sup></small></a>\n\nSome passes `false` to the finished callback if every callback in the iteration passed `false`.\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.every(set, isRegistered, finished);\n\n    function isRegistered(memo, userObject, oAuthName, callback) {\n        getOAuth(oAuthName).userExists(userObject, callback);\n    }\n\n    function finished (err, registeredOnAnyServices) {\n        if (err) throw err;\n        ...\n    }\n\n## Installation\n\n`npm install after`\n\n## Tests\n\n`make test`\n\n## Blog post\n\n[Flow control in node.js][3]\n\n## Examples :\n\n - [Determining the end of asynchronous operations][4]\n - [In javascript what are best practices for executing multiple asynchronous functions][5]\n - [JavaScript performance long running tasks][6]\n - [Synchronous database queries with node.js][7]\n\n## Contributors\n\n - Raynos\n\n## MIT Licenced\n\n  [1]: https://secure.travis-ci.org/Raynos/after.js.png\n  [2]: http://travis-ci.org/Raynos/after.js\n  [3]: http://raynos.org/blog/2/Flow-control-in-node.js\n  [4]: http://stackoverflow.com/questions/6852059/determining-the-end-of-asynchronous-operations-javascript/6852307#6852307\n  [5]: http://stackoverflow.com/questions/6869872/in-javascript-what-are-best-practices-for-executing-multiple-asynchronous-functi/6870031#6870031\n  [6]: http://stackoverflow.com/questions/6864397/javascript-performance-long-running-tasks/6889419#6889419\n  [7]: http://stackoverflow.com/questions/6597493/synchronous-database-queries-with-node-js/6620091#6620091","maintainers":[{"name":"raynos","email":"raynos2@gmail.com"}],"directories":{}},"0.3.4":{"name":"after","description":"after - tiny flow control","version":"0.3.4","author":{"name":"Raynos","email":"raynos2@gmail.com"},"contributors":[{"name":"Raynos","email":"raynos2@gmail.com","url":"http://raynos.org"}],"scripts":{"test":"make test"},"devDependencies":{"mocha":"0.10.2"},"keywords":["flowcontrol","after","flow","control","arch"],"repository":{"type":"git","url":"git://github.com/Raynos/after.js.git"},"main":"lib/after","_npmUser":{"name":"raynos","email":"raynos2@gmail.com"},"_id":"after@0.3.4","dependencies":{},"engines":{"node":"*"},"_engineSupported":true,"_npmVersion":"1.0.106","_nodeVersion":"v0.4.12","_defaultsLoaded":true,"dist":{"shasum":"ecf9b46406744027fbc29e6c8c140a237938964c","tarball":"http://registry.npmjs.org/after/-/after-0.3.4.tgz"},"maintainers":[{"name":"raynos","email":"raynos2@gmail.com"}],"directories":{}},"0.4.0":{"name":"after","description":"after - tiny flow control","version":"0.4.0","author":{"name":"Raynos","email":"raynos2@gmail.com"},"contributors":[{"name":"Raynos","email":"raynos2@gmail.com","url":"http://raynos.org"}],"scripts":{"test":"make test"},"devDependencies":{"mocha":"0.10.2"},"keywords":["flowcontrol","after","flow","control","arch"],"repository":{"type":"git","url":"git://github.com/Raynos/after.js.git"},"main":"lib/after","_npmUser":{"name":"raynos","email":"raynos2@gmail.com"},"_id":"after@0.4.0","dependencies":{},"optionalDependencies":{},"engines":{"node":"*"},"_engineSupported":true,"_npmVersion":"1.1.9","_nodeVersion":"v0.6.13","_defaultsLoaded":true,"dist":{"shasum":"0a8fbc64aae49748e5abaae9f8bd5752170a159f","tarball":"http://registry.npmjs.org/after/-/after-0.4.0.tgz"},"readme":"# After [![Build Status][1]][2]\n\nAll the flow control you'll ever need\n\n## Status: production ready\n\n## Example\n\n    var after = require(\"after\"),\n        next = after(3, logItWorks);\n\n    next();\n    next();\n    next(); // it works\n\n    function logItWorks() {\n        console.log(\"it works!\");\n    }\n\n## Motivation \n\nMinimal flow control. A lot of the libraries out there are over kill. I want a small tool that gives me fundamental concrete building blocks\n\n## Documentation\n\n### after(count, callback) <a name=\"after\" href=\"#after\"><small><sup>link</sup></small></a>\n\n`after` takes a count and a callback and returns a function `next`. The callback get's invoked when the `next` function is invoked count number of times. The callback aggregates the data given to `next` as un-ordered parameters.\n\n    var next = after(3, printData);\n\n    next(\"foo\", \"bar\", { ... })\n    next({ ... });\n    next(42);\n\n    function printData() {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            console.log(arguments[i]);  \n        }\n        // in some order\n        // 42\n        // { ... }\n        // [ \"foo\", \"bar\", { ... }]\n    }\n\nNote that the internal counter is exposed as `next.count` so you can manually increment or decrement it in a dynamic fashion. This is useful for recursively algorithms that want to increment the counter.\n\n### after.unpack(arguments) <a name=\"unpack\" href=\"#unpack\"><small><sup>link</sup></small></a>\n\nUnpack data from after using a convention\n\n``` javascript\nvar next = after(2, function () {\n    var data = after.unpack(arguments); \n    /* data = { foo: \"bar\", baz: \"boz\"}; */\n});\n\nnext(\"foo\", \"bar\");\nnext(\"baz\", \"boz\");\n```\n\n### after set utilities\n\nThe following methods are asynchronous parallel versions of the `Array.prototype` methods.\n\nThey all take parameters `(set, iterator, optionalContext, finishedCallback)`\n\n - set : the set to operate on\n - iterator : iterator function that is called for every value in the set.\n    iterator has multiple signatures. Either `(callback)` or `(value, callback)` or `(value, index, callback)` or `(value, index, obj, callback)`. The last argument is always the callback. The callback should be invoked when your done iterating over that item. You may invoke the callback with `(err, result)`\n - optionalContext : optional parameter, if given it will be the value of `this` \n    inside the iterator\n - finishedCallback : this callback is invoked when every iterator has invoked it's\n    individual callback. It has a signature of `(err, result)`. The `err` parameter\n    is whatever passed an error first or `null`. The result parameter is specific\n    to each set utility function\n\nNote that `reduce` has an `optionalInitialValue` instead of an `optionalContext`.\n\nAlso reduce's signature is `(memo, value, index, obj, callback)` or any of the shorter forms like `(memo, value, callback)`.\n\nApart from reduce and reduceRight all of these set iterators run their iterators in parallel over the set\n\n### after.forEach(set, iterator, optionalContext, finishedCallback) <a name=\"after.forEach\" href=\"#after.forEach\"><small><sup>link</sup></small></a>\n\nFor `.forEach` the `result` parameter of the finishedCallback is always undefined.\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.forEach(set, synchronizeOAuth, finished)\n\n    function synchronizeOAuth(userObject, oAuthName, callback) {\n        getOAuth(oAuthName).sychronize(userObject, callback);\n    }\n\n    function finished(err) {\n        if (err) throw err;\n    }\n\n### after.map(set, iterator, optionalContext, finishedCallback) <a name=\"after.map\" href=\"#after.map\"><small><sup>link</sup></small></a>\n\nFor `.map` the `result` parameter of the finishedCalllback is the object your mapping too.\n\nmap will return a result that either inherits from your objects prototype or is an array depending on whether the call value is an object or an array\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.map(set, getOAuthUser, finished);\n\n    function getOauthUser(userObject, oAuthName, callback) {\n        getOAuth(oAuthName).getUser(userObject, callback);\n    }\n\n    function finished (err, oAuthUserObjects) {\n        if (err) throw err;\n        for (var service in oAuthUserObjects) {\n            ...\n        }\n    }\n\n### after.reduce(set, iterator, optionalInitialValue, finishedCallback) <a name=\"after.reduce\" href=\"#after.reduce\"><small><sup>link</sup></small></a>\n\nFor `.reduce` the `result` parameter is the reduced value.\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.reduce(set, aggregateFriends, 0, finished);\n\n    function aggregateFriends(memo, userObject, oAuthName, callback) {\n        getOAuth(oAuthName)\n            .getNumberOfFriends(userObject, function (err, friends) {\n                callback(err, friends + memo);\n            });\n    }\n\n    function finished (err, numberOfFriends) {\n        if (err) throw err;\n        ...\n    }\n    \n### after.reduceRight(...) <a name=\"after.reduceRight\" href=\"#after.reduceRight\"><small><sup>link</sup></small></a>\n\n`.reduceRight` is the same as `reduce` excepts runs over the object in reverse.\n\n### after.filter(set, iterator, optionalContext, finishedCallback) <a name=\"after.filter\" href=\"#after.filter\"><small><sup>link</sup></small></a>\n\nFor `.filter` the `result` is the filtered object/array.\n\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.filter(set, isRegistered, finished);\n\n    function isRegistered(memo, userObject, oAuthName, callback) {\n        getOAuth(oAuthName).userExists(userObject, callback);\n    }\n\n    function finished (err, usersThatExist) {\n        if (err) throw err;\n        ...\n    }\n\n### after.every(set, iterator, optionalContext, finishedCallback) <a name=\"after.every\" href=\"#after.every\"><small><sup>link</sup></small></a>\n\nEvery passes `true` to the finished callback if every callback in the iteration passed `true`.\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.every(set, isRegistered, finished);\n\n    function isRegistered(memo, userObject, oAuthName, callback) {\n        getOAuth(oAuthName).userExists(userObject, callback);\n    }\n\n    function finished (err, registeredOnAllServices) {\n        if (err) throw err;\n        ...\n    }\n\n### After.some(set, iterator, optionalContext, finishedCallback) <a name=\"after.some\" href=\"#after.some\"><small><sup>link</sup></small></a>\n\nSome passes `false` to the finished callback if every callback in the iteration passed `false`.\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.every(set, isRegistered, finished);\n\n    function isRegistered(memo, userObject, oAuthName, callback) {\n        getOAuth(oAuthName).userExists(userObject, callback);\n    }\n\n    function finished (err, registeredOnAnyServices) {\n        if (err) throw err;\n        ...\n    }\n\n### <a href=\"#flow\" name=\"flow\">After.flow(array, context)</a>\n\nCreates a flow through all the functions in the array. Each function in the array is passed in the next function as the last argument. Optionally pass in a context which will be the this value for all functions\n\nafter.flow([\n    function (next) {\n        next(\"foo\")\n    },\n    function (foo, next) {\n        assert.equal(foo, \"foo\")\n        next()\n    },\n    function () {\n        assert.deepEqual(this, context)\n    }\n], context)\n\n## Installation\n\n`npm install after`\n\n## Tests\n\n`make test`\n\n## Blog post\n\n[Flow control in node.js][3]\n\n## Examples :\n\n - [Determining the end of asynchronous operations][4]\n - [In javascript what are best practices for executing multiple asynchronous functions][5]\n - [JavaScript performance long running tasks][6]\n - [Synchronous database queries with node.js][7]\n\n## Contributors\n\n - Raynos\n\n## MIT Licenced\n\n  [1]: https://secure.travis-ci.org/Raynos/after.js.png\n  [2]: http://travis-ci.org/Raynos/after.js\n  [3]: http://raynos.org/blog/2/Flow-control-in-node.js\n  [4]: http://stackoverflow.com/questions/6852059/determining-the-end-of-asynchronous-operations-javascript/6852307#6852307\n  [5]: http://stackoverflow.com/questions/6869872/in-javascript-what-are-best-practices-for-executing-multiple-asynchronous-functi/6870031#6870031\n  [6]: http://stackoverflow.com/questions/6864397/javascript-performance-long-running-tasks/6889419#6889419\n  [7]: http://stackoverflow.com/questions/6597493/synchronous-database-queries-with-node-js/6620091#6620091","maintainers":[{"name":"raynos","email":"raynos2@gmail.com"}],"directories":{}},"0.4.1":{"name":"after","description":"after - tiny flow control","version":"0.4.1","author":{"name":"Raynos","email":"raynos2@gmail.com"},"contributors":[{"name":"Raynos","email":"raynos2@gmail.com","url":"http://raynos.org"}],"scripts":{"test":"make test"},"devDependencies":{"mocha":"0.10.2"},"keywords":["flowcontrol","after","flow","control","arch"],"repository":{"type":"git","url":"git://github.com/Raynos/after.js.git"},"main":"lib/after","_npmUser":{"name":"raynos","email":"raynos2@gmail.com"},"_id":"after@0.4.1","dependencies":{},"optionalDependencies":{},"engines":{"node":"*"},"_engineSupported":true,"_npmVersion":"1.1.9","_nodeVersion":"v0.6.13","_defaultsLoaded":true,"dist":{"shasum":"a5ebed013473d4665363412e565951c196095dba","tarball":"http://registry.npmjs.org/after/-/after-0.4.1.tgz"},"readme":"# After [![Build Status][1]][2]\n\nAll the flow control you'll ever need\n\n## Status: production ready\n\n## Example\n\n    var after = require(\"after\"),\n        next = after(3, logItWorks);\n\n    next();\n    next();\n    next(); // it works\n\n    function logItWorks() {\n        console.log(\"it works!\");\n    }\n\n## Motivation \n\nMinimal flow control. A lot of the libraries out there are over kill. I want a small tool that gives me fundamental concrete building blocks\n\n## Documentation\n\n### after(count, callback) <a name=\"after\" href=\"#after\"><small><sup>link</sup></small></a>\n\n`after` takes a count and a callback and returns a function `next`. The callback get's invoked when the `next` function is invoked count number of times. The callback aggregates the data given to `next` as un-ordered parameters.\n\n    var next = after(3, printData);\n\n    next(\"foo\", \"bar\", { ... })\n    next({ ... });\n    next(42);\n\n    function printData() {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            console.log(arguments[i]);  \n        }\n        // in some order\n        // 42\n        // { ... }\n        // [ \"foo\", \"bar\", { ... }]\n    }\n\nNote that the internal counter is exposed as `next.count` so you can manually increment or decrement it in a dynamic fashion. This is useful for recursively algorithms that want to increment the counter.\n\n### after.unpack(arguments) <a name=\"unpack\" href=\"#unpack\"><small><sup>link</sup></small></a>\n\nUnpack data from after using a convention\n\n``` javascript\nvar next = after(2, function () {\n    var data = after.unpack(arguments); \n    /* data = { foo: \"bar\", baz: \"boz\"}; */\n});\n\nnext(\"foo\", \"bar\");\nnext(\"baz\", \"boz\");\n```\n\n### after set utilities\n\nThe following methods are asynchronous parallel versions of the `Array.prototype` methods.\n\nThey all take parameters `(set, iterator, optionalContext, finishedCallback)`\n\n - set : the set to operate on\n - iterator : iterator function that is called for every value in the set.\n    iterator has multiple signatures. Either `(callback)` or `(value, callback)` or `(value, index, callback)` or `(value, index, obj, callback)`. The last argument is always the callback. The callback should be invoked when your done iterating over that item. You may invoke the callback with `(err, result)`\n - optionalContext : optional parameter, if given it will be the value of `this` \n    inside the iterator\n - finishedCallback : this callback is invoked when every iterator has invoked it's\n    individual callback. It has a signature of `(err, result)`. The `err` parameter\n    is whatever passed an error first or `null`. The result parameter is specific\n    to each set utility function\n\nNote that `reduce` has an `optionalInitialValue` instead of an `optionalContext`.\n\nAlso reduce's signature is `(memo, value, index, obj, callback)` or any of the shorter forms like `(memo, value, callback)`.\n\nApart from reduce and reduceRight all of these set iterators run their iterators in parallel over the set\n\n### after.forEach(set, iterator, optionalContext, finishedCallback) <a name=\"after.forEach\" href=\"#after.forEach\"><small><sup>link</sup></small></a>\n\nFor `.forEach` the `result` parameter of the finishedCallback is always undefined.\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.forEach(set, synchronizeOAuth, finished)\n\n    function synchronizeOAuth(userObject, oAuthName, callback) {\n        getOAuth(oAuthName).sychronize(userObject, callback);\n    }\n\n    function finished(err) {\n        if (err) throw err;\n    }\n\n### after.map(set, iterator, optionalContext, finishedCallback) <a name=\"after.map\" href=\"#after.map\"><small><sup>link</sup></small></a>\n\nFor `.map` the `result` parameter of the finishedCalllback is the object your mapping too.\n\nmap will return a result that either inherits from your objects prototype or is an array depending on whether the call value is an object or an array\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.map(set, getOAuthUser, finished);\n\n    function getOauthUser(userObject, oAuthName, callback) {\n        getOAuth(oAuthName).getUser(userObject, callback);\n    }\n\n    function finished (err, oAuthUserObjects) {\n        if (err) throw err;\n        for (var service in oAuthUserObjects) {\n            ...\n        }\n    }\n\n### after.reduce(set, iterator, optionalInitialValue, finishedCallback) <a name=\"after.reduce\" href=\"#after.reduce\"><small><sup>link</sup></small></a>\n\nFor `.reduce` the `result` parameter is the reduced value.\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.reduce(set, aggregateFriends, 0, finished);\n\n    function aggregateFriends(memo, userObject, oAuthName, callback) {\n        getOAuth(oAuthName)\n            .getNumberOfFriends(userObject, function (err, friends) {\n                callback(err, friends + memo);\n            });\n    }\n\n    function finished (err, numberOfFriends) {\n        if (err) throw err;\n        ...\n    }\n    \n### after.reduceRight(...) <a name=\"after.reduceRight\" href=\"#after.reduceRight\"><small><sup>link</sup></small></a>\n\n`.reduceRight` is the same as `reduce` excepts runs over the object in reverse.\n\n### after.filter(set, iterator, optionalContext, finishedCallback) <a name=\"after.filter\" href=\"#after.filter\"><small><sup>link</sup></small></a>\n\nFor `.filter` the `result` is the filtered object/array.\n\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.filter(set, isRegistered, finished);\n\n    function isRegistered(memo, userObject, oAuthName, callback) {\n        getOAuth(oAuthName).userExists(userObject, callback);\n    }\n\n    function finished (err, usersThatExist) {\n        if (err) throw err;\n        ...\n    }\n\n### after.every(set, iterator, optionalContext, finishedCallback) <a name=\"after.every\" href=\"#after.every\"><small><sup>link</sup></small></a>\n\nEvery passes `true` to the finished callback if every callback in the iteration passed `true`.\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.every(set, isRegistered, finished);\n\n    function isRegistered(memo, userObject, oAuthName, callback) {\n        getOAuth(oAuthName).userExists(userObject, callback);\n    }\n\n    function finished (err, registeredOnAllServices) {\n        if (err) throw err;\n        ...\n    }\n\n### After.some(set, iterator, optionalContext, finishedCallback) <a name=\"after.some\" href=\"#after.some\"><small><sup>link</sup></small></a>\n\nSome passes `false` to the finished callback if every callback in the iteration passed `false`.\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.every(set, isRegistered, finished);\n\n    function isRegistered(memo, userObject, oAuthName, callback) {\n        getOAuth(oAuthName).userExists(userObject, callback);\n    }\n\n    function finished (err, registeredOnAnyServices) {\n        if (err) throw err;\n        ...\n    }\n\n### <a href=\"#flow\" name=\"flow\">After.flow(array, context)</a>\n\nCreates a flow through all the functions in the array. Each function in the array is passed in the next function as the last argument. Optionally pass in a context which will be the this value for all functions\n\n    after.flow([\n        function (next) {\n            next(null, \"foo\")\n        },\n        function (err, foo, next) {\n            assert.equal(foo, \"foo\")\n            next()\n        },\n        function (next) {\n            assert.deepEqual(this, context)\n            next(new Error(\"an error\"))\n        },\n        function () {\n            assert(false, \"this is never called\")\n        }\n    ], context, function errorCallback(err) {\n        assert.equal(err.message, \"an error\")\n    })\n\n## Installation\n\n`npm install after`\n\n## Tests\n\n`make test`\n\n## Blog post\n\n[Flow control in node.js][3]\n\n## Examples :\n\n - [Determining the end of asynchronous operations][4]\n - [In javascript what are best practices for executing multiple asynchronous functions][5]\n - [JavaScript performance long running tasks][6]\n - [Synchronous database queries with node.js][7]\n\n## Contributors\n\n - Raynos\n\n## MIT Licenced\n\n  [1]: https://secure.travis-ci.org/Raynos/after.js.png\n  [2]: http://travis-ci.org/Raynos/after.js\n  [3]: http://raynos.org/blog/2/Flow-control-in-node.js\n  [4]: http://stackoverflow.com/questions/6852059/determining-the-end-of-asynchronous-operations-javascript/6852307#6852307\n  [5]: http://stackoverflow.com/questions/6869872/in-javascript-what-are-best-practices-for-executing-multiple-asynchronous-functi/6870031#6870031\n  [6]: http://stackoverflow.com/questions/6864397/javascript-performance-long-running-tasks/6889419#6889419\n  [7]: http://stackoverflow.com/questions/6597493/synchronous-database-queries-with-node-js/6620091#6620091","maintainers":[{"name":"raynos","email":"raynos2@gmail.com"}],"directories":{}},"0.5.0":{"name":"after","description":"after - tiny flow control","version":"0.5.0","author":{"name":"Raynos","email":"raynos2@gmail.com"},"contributors":[{"name":"Raynos","email":"raynos2@gmail.com","url":"http://raynos.org"}],"scripts":{"test":"make test"},"devDependencies":{"mocha":"0.10.2"},"keywords":["flowcontrol","after","flow","control","arch"],"repository":{"type":"git","url":"git://github.com/Raynos/after.js.git"},"main":"lib/after","_npmUser":{"name":"raynos","email":"raynos2@gmail.com"},"_id":"after@0.5.0","dependencies":{},"optionalDependencies":{},"engines":{"node":"*"},"_engineSupported":true,"_npmVersion":"1.1.21","_nodeVersion":"v0.6.18","_defaultsLoaded":true,"dist":{"shasum":"a6123f193524197bb8345c9ec19d225c0c0623aa","tarball":"http://registry.npmjs.org/after/-/after-0.5.0.tgz"},"readme":"# After [![Build Status][1]][2]\n\nAll the flow control you'll ever need\n\n## Status: production ready\n\n## Example\n\n    var after = require(\"after\"),\n        next = after(3, logItWorks);\n\n    next();\n    next();\n    next(); // it works\n\n    function logItWorks() {\n        console.log(\"it works!\");\n    }\n\n## Motivation \n\nMinimal flow control. A lot of the libraries out there are over kill. I want a small tool that gives me fundamental concrete building blocks\n\n## Documentation\n\n### after(count, callback) <a name=\"after\" href=\"#after\"><small><sup>link</sup></small></a>\n\n`after` takes a count and a callback and returns a function `next`. The callback get's invoked when the `next` function is invoked count number of times. The callback aggregates the data given to `next` as un-ordered parameters.\n\n    var next = after(3, printData);\n\n    next(\"foo\", \"bar\", { ... })\n    next({ ... });\n    next(42);\n\n    function printData() {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            console.log(arguments[i]);  \n        }\n        // in some order\n        // 42\n        // { ... }\n        // [ \"foo\", \"bar\", { ... }]\n    }\n\nNote that the internal counter is exposed as `next.count` so you can manually increment or decrement it in a dynamic fashion. This is useful for recursively algorithms that want to increment the counter.\n\n### after.unpack(arguments) <a name=\"unpack\" href=\"#unpack\"><small><sup>link</sup></small></a>\n\nUnpack data from after using a convention\n\n``` javascript\nvar next = after(2, function () {\n    var data = after.unpack(arguments); \n    /* data = { foo: \"bar\", baz: \"boz\"}; */\n});\n\nnext(\"foo\", \"bar\");\nnext(\"baz\", \"boz\");\n```\n\n### after set utilities\n\nThe following methods are asynchronous parallel versions of the `Array.prototype` methods.\n\nThey all take parameters `(set, iterator, optionalContext, finishedCallback)`\n\n - set : the set to operate on\n - iterator : iterator function that is called for every value in the set.\n    iterator has multiple signatures. Either `(callback)` or `(value, callback)` or `(value, index, callback)` or `(value, index, obj, callback)`. The last argument is always the callback. The callback should be invoked when your done iterating over that item. You may invoke the callback with `(err, result)`\n - optionalContext : optional parameter, if given it will be the value of `this` \n    inside the iterator\n - finishedCallback : this callback is invoked when every iterator has invoked it's\n    individual callback. It has a signature of `(err, result)`. The `err` parameter\n    is whatever passed an error first or `null`. The result parameter is specific\n    to each set utility function\n\nNote that `reduce` has an `optionalInitialValue` instead of an `optionalContext`.\n\nAlso reduce's signature is `(memo, value, index, obj, callback)` or any of the shorter forms like `(memo, value, callback)`.\n\nApart from reduce and reduceRight all of these set iterators run their iterators in parallel over the set\n\n### after.forEach(set, iterator, optionalContext, finishedCallback) <a name=\"after.forEach\" href=\"#after.forEach\"><small><sup>link</sup></small></a>\n\nFor `.forEach` the `result` parameter of the finishedCallback is always undefined.\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.forEach(set, synchronizeOAuth, finished)\n\n    function synchronizeOAuth(userObject, oAuthName, callback) {\n        getOAuth(oAuthName).sychronize(userObject, callback);\n    }\n\n    function finished(err) {\n        if (err) throw err;\n    }\n\n### after.map(set, iterator, optionalContext, finishedCallback) <a name=\"after.map\" href=\"#after.map\"><small><sup>link</sup></small></a>\n\nFor `.map` the `result` parameter of the finishedCalllback is the object your mapping too.\n\nmap will return a result that either inherits from your objects prototype or is an array depending on whether the call value is an object or an array\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.map(set, getOAuthUser, finished);\n\n    function getOauthUser(userObject, oAuthName, callback) {\n        getOAuth(oAuthName).getUser(userObject, callback);\n    }\n\n    function finished (err, oAuthUserObjects) {\n        if (err) throw err;\n        for (var service in oAuthUserObjects) {\n            ...\n        }\n    }\n\n### after.reduce(set, iterator, optionalInitialValue, finishedCallback) <a name=\"after.reduce\" href=\"#after.reduce\"><small><sup>link</sup></small></a>\n\nFor `.reduce` the `result` parameter is the reduced value.\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.reduce(set, aggregateFriends, 0, finished);\n\n    function aggregateFriends(memo, userObject, oAuthName, callback) {\n        getOAuth(oAuthName)\n            .getNumberOfFriends(userObject, function (err, friends) {\n                callback(err, friends + memo);\n            });\n    }\n\n    function finished (err, numberOfFriends) {\n        if (err) throw err;\n        ...\n    }\n    \n### after.reduceRight(...) <a name=\"after.reduceRight\" href=\"#after.reduceRight\"><small><sup>link</sup></small></a>\n\n`.reduceRight` is the same as `reduce` excepts runs over the object in reverse.\n\n### after.filter(set, iterator, optionalContext, finishedCallback) <a name=\"after.filter\" href=\"#after.filter\"><small><sup>link</sup></small></a>\n\nFor `.filter` the `result` is the filtered object/array.\n\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.filter(set, isRegistered, finished);\n\n    function isRegistered(memo, userObject, oAuthName, callback) {\n        getOAuth(oAuthName).userExists(userObject, callback);\n    }\n\n    function finished (err, usersThatExist) {\n        if (err) throw err;\n        ...\n    }\n\n### after.every(set, iterator, optionalContext, finishedCallback) <a name=\"after.every\" href=\"#after.every\"><small><sup>link</sup></small></a>\n\nEvery passes `true` to the finished callback if every callback in the iteration passed `true`.\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.every(set, isRegistered, finished);\n\n    function isRegistered(memo, userObject, oAuthName, callback) {\n        getOAuth(oAuthName).userExists(userObject, callback);\n    }\n\n    function finished (err, registeredOnAllServices) {\n        if (err) throw err;\n        ...\n    }\n\n### After.some(set, iterator, optionalContext, finishedCallback) <a name=\"after.some\" href=\"#after.some\"><small><sup>link</sup></small></a>\n\nSome passes `false` to the finished callback if every callback in the iteration passed `false`.\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.every(set, isRegistered, finished);\n\n    function isRegistered(memo, userObject, oAuthName, callback) {\n        getOAuth(oAuthName).userExists(userObject, callback);\n    }\n\n    function finished (err, registeredOnAnyServices) {\n        if (err) throw err;\n        ...\n    }\n\n### <a href=\"#flow\" name=\"flow\">After.flow(array, context)</a>\n\nCreates a flow through all the functions in the array. Each function in the array is passed in the next function as the last argument. Optionally pass in a context which will be the this value for all functions\n\n    after.flow([\n        function (next) {\n            next(null, \"foo\")\n        },\n        function (err, foo, next) {\n            assert.equal(foo, \"foo\")\n            next()\n        },\n        function (next) {\n            assert.deepEqual(this, context)\n            next(new Error(\"an error\"))\n        },\n        function () {\n            assert(false, \"this is never called\")\n        }\n    ], context, function errorCallback(err) {\n        assert.equal(err.message, \"an error\")\n    })\n\n## Installation\n\n`npm install after`\n\n## Tests\n\n`make test`\n\n## Blog post\n\n[Flow control in node.js][3]\n\n## Examples :\n\n - [Determining the end of asynchronous operations][4]\n - [In javascript what are best practices for executing multiple asynchronous functions][5]\n - [JavaScript performance long running tasks][6]\n - [Synchronous database queries with node.js][7]\n\n## Contributors\n\n - Raynos\n\n## MIT Licenced\n\n  [1]: https://secure.travis-ci.org/Raynos/after.js.png\n  [2]: http://travis-ci.org/Raynos/after.js\n  [3]: http://raynos.org/blog/2/Flow-control-in-node.js\n  [4]: http://stackoverflow.com/questions/6852059/determining-the-end-of-asynchronous-operations-javascript/6852307#6852307\n  [5]: http://stackoverflow.com/questions/6869872/in-javascript-what-are-best-practices-for-executing-multiple-asynchronous-functi/6870031#6870031\n  [6]: http://stackoverflow.com/questions/6864397/javascript-performance-long-running-tasks/6889419#6889419\n  [7]: http://stackoverflow.com/questions/6597493/synchronous-database-queries-with-node-js/6620091#6620091","maintainers":[{"name":"raynos","email":"raynos2@gmail.com"}],"directories":{}},"0.6.0":{"name":"after","description":"after - tiny flow control","version":"0.6.0","author":{"name":"Raynos","email":"raynos2@gmail.com"},"contributors":[{"name":"Raynos","email":"raynos2@gmail.com","url":"http://raynos.org"}],"scripts":{"test":"make test"},"devDependencies":{"mocha":"0.10.2"},"keywords":["flowcontrol","after","flow","control","arch"],"repository":{"type":"git","url":"git://github.com/Raynos/after.js.git"},"main":"lib/after","readme":"# After [![Build Status][1]][2]\n\nInvoke callback after n calls\n\n## Status: production ready\n\n## Example\n\n    var after = require(\"after\")\n        , next = after(3, logItWorks)\n\n    next()\n    next()\n    next() // it works\n\n    function logItWorks() {\n        console.log(\"it works!\")\n    }\n\n## Example with error handling\n\n    var after = require(\"after\")\n        , next = after(3, logError)\n\n    next()\n    next(new Error(\"oops\")) // logs oops\n    next() // does nothing\n\n    function logError(err) {\n        console.log(err)\n    }\n\n## After < 0.6.0\n\nOlder versions of after had iterators and flows in them.\n\nThese have been replaced with seperate modules\n\n - [iterators][8]\n - [composite][9]\n\n## Installation\n\n`npm install after`\n\n## Tests\n\n`make test`\n\n## Blog post\n\n - [Flow control in node.js][3]\n\n## Examples :\n\n - [Determining the end of asynchronous operations][4]\n - [In javascript what are best practices for executing multiple asynchronous functions][5]\n - [JavaScript performance long running tasks][6]\n - [Synchronous database queries with node.js][7]\n\n## Contributors\n\n - Raynos\n\n## MIT Licenced\n\n  [1]: https://secure.travis-ci.org/Raynos/after.js.png\n  [2]: http://travis-ci.org/Raynos/after.js\n  [3]: http://raynos.org/blog/2/Flow-control-in-node.js\n  [4]: http://stackoverflow.com/questions/6852059/determining-the-end-of-asynchronous-operations-javascript/6852307#6852307\n  [5]: http://stackoverflow.com/questions/6869872/in-javascript-what-are-best-practices-for-executing-multiple-asynchronous-functi/6870031#6870031\n  [6]: http://stackoverflow.com/questions/6864397/javascript-performance-long-running-tasks/6889419#6889419\n  [7]: http://stackoverflow.com/questions/6597493/synchronous-database-queries-with-node-js/6620091#6620091\n  [8]: http://github.com/Raynos/iterators\n  [9]: http://github.com/Raynos/composite","_id":"after@0.6.0","dist":{"shasum":"0e7a62d35ffe2eedb4eb4081d3905d4081e6fc20","tarball":"http://registry.npmjs.org/after/-/after-0.6.0.tgz"},"maintainers":[{"name":"raynos","email":"raynos2@gmail.com"}],"directories":{}},"0.7.0":{"name":"after","description":"after - tiny flow control","version":"0.7.0","author":{"name":"Raynos","email":"raynos2@gmail.com"},"contributors":[{"name":"Raynos","email":"raynos2@gmail.com","url":"http://raynos.org"}],"scripts":{"test":"mocha --ui tdd --reporter spec test/*.js"},"devDependencies":{"mocha":"~1.8.1"},"keywords":["flowcontrol","after","flow","control","arch"],"repository":{"type":"git","url":"git://github.com/Raynos/after.git"},"main":"lib/after","readme":"# After [![Build Status][1]][2]\n\nInvoke callback after n calls\n\n## Status: production ready\n\n## Example\n\n    var after = require(\"after\")\n        , next = after(3, logItWorks)\n\n    next()\n    next()\n    next() // it works\n\n    function logItWorks() {\n        console.log(\"it works!\")\n    }\n\n## Example with error handling\n\n    var after = require(\"after\")\n        , next = after(3, logError)\n\n    next()\n    next(new Error(\"oops\")) // logs oops\n    next() // does nothing\n\n    function logError(err) {\n        console.log(err)\n    }\n\n## After < 0.6.0\n\nOlder versions of after had iterators and flows in them.\n\nThese have been replaced with seperate modules\n\n - [iterators][8]\n - [composite][9]\n\n## Installation\n\n`npm install after`\n\n## Tests\n\n`make test`\n\n## Blog post\n\n - [Flow control in node.js][3]\n\n## Examples :\n\n - [Determining the end of asynchronous operations][4]\n - [In javascript what are best practices for executing multiple asynchronous functions][5]\n - [JavaScript performance long running tasks][6]\n - [Synchronous database queries with node.js][7]\n\n## Contributors\n\n - Raynos\n\n## MIT Licenced\n\n  [1]: https://secure.travis-ci.org/Raynos/after.png\n  [2]: http://travis-ci.org/Raynos/after\n  [3]: http://raynos.org/blog/2/Flow-control-in-node.js\n  [4]: http://stackoverflow.com/questions/6852059/determining-the-end-of-asynchronous-operations-javascript/6852307#6852307\n  [5]: http://stackoverflow.com/questions/6869872/in-javascript-what-are-best-practices-for-executing-multiple-asynchronous-functi/6870031#6870031\n  [6]: http://stackoverflow.com/questions/6864397/javascript-performance-long-running-tasks/6889419#6889419\n  [7]: http://stackoverflow.com/questions/6597493/synchronous-database-queries-with-node-js/6620091#6620091\n  [8]: http://github.com/Raynos/iterators\n  [9]: http://github.com/Raynos/composite\n","readmeFilename":"README.md","_id":"after@0.7.0","dist":{"shasum":"b074e121f64391ba7265cd2bbdc6a8504380946a","tarball":"http://registry.npmjs.org/after/-/after-0.7.0.tgz"},"_from":".","_npmVersion":"1.2.11","_npmUser":{"name":"shtylman","email":"shtylman@gmail.com"},"maintainers":[{"name":"raynos","email":"raynos2@gmail.com"},{"name":"shtylman","email":"shtylman@gmail.com"}],"directories":{}},"0.8.1":{"name":"after","description":"after - tiny flow control","version":"0.8.1","author":{"name":"Raynos","email":"raynos2@gmail.com"},"contributors":[{"name":"Raynos","email":"raynos2@gmail.com","url":"http://raynos.org"}],"scripts":{"test":"mocha --ui tdd --reporter spec test/*.js"},"devDependencies":{"mocha":"~1.8.1"},"keywords":["flowcontrol","after","flow","control","arch"],"repository":{"type":"git","url":"git://github.com/Raynos/after.git"},"readme":"# After [![Build Status][1]][2]\n\nInvoke callback after n calls\n\n## Status: production ready\n\n## Example\n\n    var after = require(\"after\")\n        , next = after(3, logItWorks)\n\n    next()\n    next()\n    next() // it works\n\n    function logItWorks() {\n        console.log(\"it works!\")\n    }\n\n## Example with error handling\n\n    var after = require(\"after\")\n        , next = after(3, logError)\n\n    next()\n    next(new Error(\"oops\")) // logs oops\n    next() // does nothing\n\n    function logError(err) {\n        console.log(err)\n    }\n\n## After < 0.6.0\n\nOlder versions of after had iterators and flows in them.\n\nThese have been replaced with seperate modules\n\n - [iterators][8]\n - [composite][9]\n\n## Installation\n\n`npm install after`\n\n## Tests\n\n`npm test`\n\n## Blog post\n\n - [Flow control in node.js][3]\n\n## Examples :\n\n - [Determining the end of asynchronous operations][4]\n - [In javascript what are best practices for executing multiple asynchronous functions][5]\n - [JavaScript performance long running tasks][6]\n - [Synchronous database queries with node.js][7]\n\n## Contributors\n\n - Raynos\n\n## MIT Licenced\n\n  [1]: https://secure.travis-ci.org/Raynos/after.png\n  [2]: http://travis-ci.org/Raynos/after\n  [3]: http://raynos.org/blog/2/Flow-control-in-node.js\n  [4]: http://stackoverflow.com/questions/6852059/determining-the-end-of-asynchronous-operations-javascript/6852307#6852307\n  [5]: http://stackoverflow.com/questions/6869872/in-javascript-what-are-best-practices-for-executing-multiple-asynchronous-functi/6870031#6870031\n  [6]: http://stackoverflow.com/questions/6864397/javascript-performance-long-running-tasks/6889419#6889419\n  [7]: http://stackoverflow.com/questions/6597493/synchronous-database-queries-with-node-js/6620091#6620091\n  [8]: http://github.com/Raynos/iterators\n  [9]: http://github.com/Raynos/composite\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/Raynos/after/issues"},"_id":"after@0.8.1","dist":{"shasum":"ab5d4fb883f596816d3515f8f791c0af486dd627","tarball":"http://registry.npmjs.org/after/-/after-0.8.1.tgz"},"_from":".","_npmVersion":"1.2.25","_npmUser":{"name":"raynos","email":"raynos2@gmail.com"},"maintainers":[{"name":"raynos","email":"raynos2@gmail.com"},{"name":"shtylman","email":"shtylman@gmail.com"}],"directories":{}}},"maintainers":[{"name":"raynos","email":"raynos2@gmail.com"},{"name":"shtylman","email":"shtylman@gmail.com"}],"time":{"modified":"2013-11-12T23:59:10.772Z","created":"2011-08-15T14:01:15.289Z","0.1.0":"2011-12-08T01:56:13.312Z","0.1.3":"2011-12-08T01:56:13.312Z","0.1.4":"2011-12-08T01:56:13.312Z","0.1.5":"2011-12-08T01:56:13.312Z","0.1.6":"2011-12-08T01:56:13.312Z","0.1.7":"2011-11-10T15:31:29.230Z","0.1.8":"2011-12-02T18:29:43.571Z","0.2.0":"2011-12-08T01:56:13.312Z","0.3.1":"2012-01-30T01:04:13.451Z","0.3.2":"2012-02-28T11:38:51.930Z","0.3.3":"2012-03-04T20:38:46.024Z","0.3.4":"2012-04-11T23:44:38.170Z","0.4.0":"2012-04-23T10:50:58.605Z","0.4.1":"2012-05-08T19:20:57.272Z","0.5.0":"2012-05-30T15:58:26.661Z","0.6.0":"2012-07-15T06:05:34.045Z","0.7.0":"2013-02-26T22:21:25.548Z","0.8.1":"2013-06-30T06:09:40.954Z"},"author":{"name":"Raynos","email":"raynos2@gmail.com"},"repository":{"type":"git","url":"git://github.com/Raynos/after.git"},"users":{"luk":true,"shtylman":true,"hij1nx":true,"meggesje":true,"pid":true,"daviddias":true,"syzer":true,"kesla":true,"rsalesc":true,"trycatch9264":true},"_attachments":{},"_etag":"\"7QR7XVFLX975WD8A16JMFSDI3\""}